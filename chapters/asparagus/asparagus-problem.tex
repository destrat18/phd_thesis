\section{Gas Upper-Bound as a Synthesis Problem}\label{sec:asparagus-problem} 

\para{Our Focus} In this chapter, we focus on the problem of automated synthesis of parametric bounds on the gas usage of a smart contract. This problem is well-studied in the literature. There are two main motivations for automated bound synthesis: (i)~ensuring that a contract can safely call libraries and functions in other contracts, and (ii)~avoiding out-of-gas vulnerabilities, where wrong estimations of the gas behavior of a smart contract can lead to catastrophic real-world consequences. In the simplest case, if a user mistakenly underestimates the amount of gas that is needed for the execution of their desired function call and chooses a maximum gas value that is too small, then they would lose their entire deposit in the process above. This happens even if the estimate was just one unit short of the required gas. While this is irritating, out-of-gas errors can lead to much more severe losses, as further described below. Moreover, the decision on the allocated gas is not always taken by the final user, but often by the programmer of a smart contract.

\para{Problem Formulation} In this chapter, we focus on the problem of automated synthesis of parametric upper-bounds for a given smart contract $\mathscr{C}$. Our goal is to find a parametric expression $B_f$ for every function $f$ of $\mathscr{C}$, such that $B_f,$ which can potentially depend on the parameters passed to $f,$ the variables stored in $\mathscr{C},$ and the gas usage of other functions called by $f,$ serves as a guaranteed upper-bound on the gas usage of any call to $f.$ Of course, we would like each $B_f$ to be as tight as possible.

\para{Related Works} Due to the importance of avoiding out-of-gas vulnerabilities, this is a well-studied problem and there are several previous tools that attempt to solve it. Notably, \texttt{solc}, the standard compiler of Solidity, which is the most commonly used programming language for Ethereum smart contracts, already includes a static analyzer that tries to find such upper-bounds and issues a warning to the programmer if it cannot prove that a function has small gas usage. However, these tools are only able to find constant bounds on the gas usage and would simply report $+\infty$ as their bound if no such constant can be found. To the best of our knowledge, the only exception is GASTAP~\cite{albert2021don1}, which was the only previous tool to provide parametric bounds. We provide an extensive experimental comparison with GASTAP in Section~\ref{sec:asparagus-experiments}.

\para{Undecidability and Limitations} The general case of our problem, where $\mathscr{C}$ can be any contract written in a Turing-complete language, is clearly undecidable since $B_f$ is finite if and only if $f$ terminates and thus halting is a special case of our problem. Therefore, we apply some abstractions and allow only numerical variables in the smart contracts. Specifically, we abstract away the arrays and instead just keep track of their size. These abstractions are sound, but not necessarily complete. Moreover, we focus on synthesizing polynomial upper-bounds $B_f$. See Section~\ref{sec:prelim-ethereum} for more formal treatment. Thus, our approach can only find polynomial bounds over polynomial transition systems. This excludes non-polynomial smart contracts. It also excludes contracts written in functional programming languages such as Scilla~\cite{sergey2019safer}, which may contain higher-order functions.


\para{Motivation for Polynomial Bounds} In our experimental result, $653$ (2.7\%) of the benchmarks required quadratic polynomial bounds. These are usually contracts that compute hashes or allocate memory within loops. Thus, no constant or linear bounds exist in these cases and non-linear bounds are required. Polynomial bounds are also desirable for the following additional reasons:
\begin{itemize}
    \item Certain EVM operations, such as \texttt{MSTORE}, incur memory expansion costs which are \emph{quadratic} in size of the used memory. To handle contracts that use a non-constant amount of memory, one has to go beyond linear bounds and introduce polynomials.

    \item At the time of writing, the gas price is too high, leading many smart contract programmers to avoid loops altogether. This is a major issue that is artificially keeping the contracts simple and not allowing them to exploit the promise of a Turing-complete language. Indeed, the vast majority of functions our experiments had constant gas usage. We expect that with the recent switch to proof-of-stake and proposals for relaxations of the block gas limit, the gas price would decrease significantly, allowing smart contract programmers to write more complicated functionality. Thus, our expectation is to see more contracts with non-linear gas usage in the future.

    \item Our approach outperforms both \texttt{solc} and GASTAP even in the cases when the gas bound is constant. Additionally, our bounds are tighter even when both approaches synthesize constant or linear bounds. These gains are due to the extra expressivity of our polynomial templates.
\end{itemize}
