\section{Experimental Results}\label{sec:hermes-experiments} 

\para{Implementation} We implemented our algorithm in Python 3 as a tool named Hermes. Hermes is open-source and released into the public domain. Our implementation leverages the Python library NetworkX~\cite{hagberg2008exploring} for graph operations and tree decompositions. Hermes is available at \url{https://github.com/SanazSafaei/Hermes-Structure-Aware-Optimal-DEX-Routing}.


\para{Benchmarks and Experimental Setting} We collected a comprehensive dataset by capturing snapshots of all Uniswap liquidity pools across \todo{$20{,}000$} consecutive blocks, specifically from block~\todo{$22{,}820{,}000$} to block~\todo{$22{,}839{,}999$}. Data were collected using the official Uniswap APIs~\cite{theUniswapSubgraph}. We evaluated Hermes in comparison with the state of the art Modified Moore Bellman Ford algorithm~\cite{zhang2024improved}, which is the only existing graph based method. For additional comparison, we also included the standard Bellman Ford algorithm as a baseline. For each block, we constructed the corresponding token graph and queried SSSPs from $100$ randomly selected tokens, recording the average query time per block. To further assess scalability, we repeated this procedure for four different token set sizes: the top $100$, $1{,}000$, $10{,}000$, and $100{,}000$ tokens, ranked by TVL in USD. Each query was subject to a 12-second timeout, matching the average Ethereum block interval.

\para{Treewidth} Experimental analysis shows that the average treewidth for token sets of sizes $100$, $1{,}000$, $10{,}000$, and $100{,}000$ is \todo{$8$}, \todo{$18$}, \todo{$38$}, and \todo{$71$}, respectively. As illustrated in Figure~\ref{fig:hermes-treewidth}, while treewidth increases with the number of tokens, its growth rate is substantially slower than that of the total number of tokens. These results demonstrate the suitability of parameterized algorithms for this problem.

\para{Dynamics of Pool Updates} For the token set sizes studied, we observed an average of \todo{9.7} price updates per block, about \todo{1} new token every \todo{$12$} blocks, and about \todo{1} new pool every \todo{$33$} blocks, reflecting few edge weight changes and infrequent additions of vertices and edges. Figure~\ref{fig:hermes-histogram-update-price} shows the distribution of price updates across blocks.~These results show that the proposed approach for handling dynamic edges is practical for real-world pools.


\begin{figure}[ht]
    \centering
    \includegraphics[width=.8\columnwidth]{chapters/hermes/hermes-figures/treewidth\_vs\_tokens.pdf}
    \caption{Comparison of the growth rates of the number of tokens and the treewidth.}
    \label{fig:hermes-treewidth}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=.8\columnwidth]{chapters/hermes/hermes-figures/histogram\_update\_price.pdf}
    \caption{Histogram of token price updates per block.}
    \label{fig:hermes-histogram-update-price}
\end{figure}


\para{Robustness} We measured the success rate of Hermes in finding valid routes, compared to MMBF and BF, by running \todo{$2{,}000{,}000$} queries for each of the four token set sizes. Hermes successfully solved \todo{\textbf{100\%}} of queries, while MMBF and BF solved only \todo{\textbf{25\%}} and \todo{\textbf{1.4\%}}, respectively. The primary limitation for MMBF was frequent timeouts when the token count exceeded $100$. For BF, failures on smaller token sets $100$, $1{,}000$ were mainly due to negative cycles, while timeouts dominated for larger sets $10{,}000$ and $100{,}000$. Table~\ref{table:hermes-solvedComp} summarizes the success rates and coverage for all three algorithms.

\para{Scalability} We evaluated the runtime performance of all algorithms. MMBF completed within the time limit only for the smallest token set of $100$, which precludes direct runtime comparison on larger sizes. On this benchmark, Hermes achieved an average query time of \todo{\textbf{0.0002}} seconds, while MMBF required \todo{$2.8191$} seconds, representing an improvement of four orders of magnitude. BF completed within the time limit for token sets of size $100$ and $1{,}000$ mainly. For queries solved by both Hermes and BF, Hermes averaged \todo{$0.054$} seconds per query, compared to \todo{$0.5947$} seconds for BF. It is important to note that BF frequently failed to return valid routes on \todo{97.8\%} of queries owing to the presence of negative cycles, which rendered the majority of its results unusable. Hermes was the only method able to process the largest token sets, with average query times of \todo{\textbf{0.0197}} seconds and \todo{\textbf{0.1942}} seconds for $10{,}000$ and $100{,}000$ tokens, respectively. Detailed results are presented in Table~\ref{table:hermes-runtime}.


\begin{table}
    \centering
    \huge{\input{chapters/hermes/hermes-tables/solvedComp.tex}}
    \caption{Success rates for Hermes (ours), MMBF, and BF on routing queries for four token set sizes. ``Failed'' indicates cases where the tool did not work due to negative cycles.}
    \label{table:hermes-solvedComp}
\end{table}


\begin{table}
    \centering
    \huge{\input{chapters/hermes/hermes-tables/runtimeResult.tex}}
    \caption{Average runtimes (in seconds) for Hermes (ours), MMBF, and BF across different token set sizes. The ``Completed'' column indicates the number of queries finished within the timeout; ``TIMEOUT'' denotes that all queries exceeded the time limit.}
    \label{table:hermes-runtime}
\end{table}