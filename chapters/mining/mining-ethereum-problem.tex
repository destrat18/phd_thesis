\section{Problem of Ethereum Block Production}\label{sec/mining-ethereum-problem} 

Our goal in this section is to develop an optimization approach to increase the transaction-fee (gas) revenues of Ethereum miners. Although we focus on Ethereum, our techniques are general in nature and can be applied to other programmable blockchains as well. There are two reasons for the emphasis on Ethereum: First, Ethereum is currently the world's second largest cryptocurrency by market cap, behind only Bitcoin. At the time of writing, it has a total value of around 250 billion USD~\cite{coinmarketcap2024cryptocurrency}. 
It is also by far the largest programmable cryptocurrency, with support for arbitrary smart contracts written in a Turing-complete language~\cite{wood2014ethereum}. Second, Ethereum has an account-based execution model which is significantly different than the UTXO (Unspent Transaction Output) model of Bitcoin. Thus, there is a research gap as the techniques developed for Bitcoin and other UTXO miners, such as Section~\ref{sec:mining-cardano-problem}, are not applicable in our context. 


\subsection{Problem Definition} \label{sec:def}

\paragraph{Our Focus} In this section, we address the problem of maximizing the total transaction fee revenue of an honest miner, i.e.~a miner who does not perform attacks or seek revenue from non-transaction-fee sources such as smart contract interactions. Such a miner listens for newly-broadcast transactions not yet added to the blockchain and selects an ordered subset to form her block. The goal is to maximize the sum of tips paid by the transactions.

\paragraph{Formal Definition of the Problem} Suppose that the miner intends to add the $k$-th block to the blockchain. Let $\pool$ be the set of new valid transactions known to the miner which are not yet added on thse blockchain. A block is a sequence $B = \langle \tx_1, \tx_2, \ldots, \tx_n \rangle$ of transactions from $\pool$ such that for every $i < j,$ if $\tx_i$ and $\tx_j$ belong to the same user $a$, then $\tx_i$'s nonce is smaller than $\tx_j$'s nonce. Moreover, if there is a transaction from $a$ with nonce $\nu \geq 1,$ then there should be a previous transaction from the same user $a$ with nonce $\nu-1$ either in the same block or in previous blocks that are already added to the blockchain. This ensures that every transaction is added at most once and that the transactions by the same user cannot be reordered. Denote the world state at the end of the previous block ($k-1$) by $s_0 \in S.$ For all $1 \leq i \leq n,$ define 
$$s_i = \delta_{\tx_i}(s_{i-1}) \quad\quad\quad \gamma_i = \gas_{\tx_i}(s_{i-1}) \quad\quad\quad \tau_i = \tip_{\tx_i}(s_{i-1}).$$
Intuitively, assuming that the miner appends $B$ to the blockchain, $s_i$ is the world state after $\tx_i$ has finished running, $\gamma_i$ is the gas usage of $\tx_i$ and $\tau_i$ is the total tip paid by $\tx_i$ to the miner 
(formal definitions and details can be found in Section~\ref{sec:prelim}).
The miner aims to maximize the tips, while not exceeding the block gas limit $L$. Thus, the optimization problem is to find a valid block $B$ so as to:
$$
\begin{matrix}
	\textbf{max} & \displaystyle \sum_{i=1}^n \tau_i & \quad & \textbf{s.t.} & \displaystyle \sum_{i=1}^n \gamma_i \leq L
\end{matrix}
$$



\paragraph{Our Algorithmic Contribution} In Section~\ref{sec:algo}, we design and present a randomized algorithm that combines testing, decision trees, localization techniques and integer linear programming (ILP) to handle the optimization problem above. We start by executing several test cases, i.e.~random permutations of the transactions in our $\pool,$ and profiling their gas usage. Then, using decision trees, for every transaction $\tx \in \pool,$ we find a set of other transactions that can affect its gas usage. We call this the neighborhood of $\tx$ and denote it as $\nbhd(\tx).$ Intuitively, we expect the neighborhood of every vertex to be small since, in real-world instances, most transactions are completely independent of each other. For example, a pair of transactions that do not access the same smart contracts cannot affect each other's gas usage, either. We provide a probabilistic argument showing that with high probability our testing covers every possible permutation of each neighborhood. Thus, we can cut, mix and glue together parts of our test cases in order to create a block that maximizes the miner's total tip revenue. This part is modeled as an integer linear programming instance and solved by an external optimization suite. All steps of our algorithm are parallelizable and, except for the ILP solver, run in polynomial time. Due to its reliance on randomized sampling and ILP-solvers, our algorithm is not guaranteed to always produce an optimal result.

\paragraph{Our Practical Contribution} We implemented our algorithm and performed extensive experimental results on 50,000 Ethereum blocks. For each block, we gathered real-world transaction pool data and executed our algorithm. We then compared the tip revenues obtained by our framework and those of real-world miners. Our approach increased tip revenues by a significant margin of 73.45 percent on average per block, corresponding to roughly 24.1 USD per block and 63,357,892 USD per year at current exchange rates. We also compared our tool against the default Ethereum implementation and found that our approach increased tip revenues by 18.56 percent on average per block, corresponding to roughly 17.3 USD per block and 45,416,764 USD per year. Our tool is free, open-source and dedicated to the public domain with a perpetual copyright waiver. It is accessible at \url{https://anonymous.4open.science/r/boosting_gas_revenues_of_ethereum_miners/}.


\subsection{Ethereum Architecture}
\label{sec:mining-ethereum-prelim}

The remainder of this subsection outlines the specific components of the Ethereum architecture that are prerequisites to our algorithm. Refer to Section~\ref{sec:prelim-ethereum} for a more comprehensive background.

\paragraph{Details of Transaction Fees~\cite{ethereumgasfees,dameron2018beigepaper}} When creating a transaction, the user should set a maximum amount $m$ of gas that the transaction is allowed to consume. They should also set a price $p$ that they are willing to pay per unit of gas. Right before the transaction's execution, a deposit of $m \cdot p$ is taken from the user's account. If the transaction uses $g \leq m$ units of gas in its execution, then the transaction fee will be $g \cdot p$ and the user receives a refund of $(m-g) \cdot p.$ Otherwise, if $g > m,$ an out-of-gas error is raised. This sets $g=m.$ When running out of gas, all effects of the transaction are reverted. However, the deposit is not refunded and the entire $m \cdot p$ is taken as a transaction fee. 

\paragraph{Base Fees and Tips~\cite{ethereumgasfees,dameron2018beigepaper}} The gas price $p = b + t$ consists of two parts: a base fee $b$ which is the same for all transactions in the block and a tip $t$ which is picked by the user starting the transaction. If the transaction uses $g$ units of gas, the user pays a transaction fee of $g \cdot p$ as mentioned above. Of this, $g \cdot b$ units are burned and $g \cdot t$ is paid to the miner who added the transaction to the blockchain. There are two clear reasons behind the base fee: (i)~it controls inflation by destroying some units of currency, and (ii)~the protocol can balance the supply and demand of block space. Ethereum aims to have blocks that use roughly 15,000,000 units of gas which is almost half of the block gas limit. If a block uses more than this amount, it shows that demand for gas is high and thus the base fee goes up in future blocks. Conversely, if a block uses less than 15,000,000 units, e.g.~if it is almost empty, the base fee drops.


\paragraph{Structure of an Ethereum Transaction} A formal specification for Ethereum transactions is given in~\cite{dameron2018beigepaper}. Each transaction $\tx$ contains a nonce, a counter showing the number of transactions issued by the current user to date. It also contains the gas parameters $m$ and $p = b + t$ above. If the transaction transfers money, it includes the recipient address and amount. Similarly, if it deploys a contract it includes its code, and if it calls a function, it includes its parameters. We ignore these details and focus on the fact that, given the world state before the execution of $\tx,$ its gas usage and the total tip paid to the miner are uniquely determined. Thus, letting $S$ be the set of all possible world states, from the miner's point-of-view, the transaction $\tx$ induces two functions:
$$
\gas_\tx : S \rightarrow \mathbb{N} \quad\quad\quad \tip_\tx : S \rightarrow \mathbb{N}.
$$
Note that $\tip_\tx \equiv t \cdot \gas_\tx.$ Similarly, since executing $\tx$ changes the world state, the transaction induces a transition function $\delta_\tx : S \rightarrow S$ between world states.





\paragraph{Optimal Mining on UTXO Blockchains} In the UTXO model, as discussed in Section~\ref{sec:mining-cardano-problem}, transactions can have dependencies and conflicts. For example, if Alice receives money in $\tx_1$ and uses it to pay Bob in $\tx_2,$ i.e.~an input of $\tx_2$ is an output of $\tx_1,$ then $\tx_2$ can only be added to the blockchain after $\tx_1$. On the other hand, if Alice receives money in $\tx_1$ and then creates distinct transactions $\tx_2$ and $\tx_3$ that use the same coin twice then at most one of them can be added to the consensus chain.  Thus, optimizing a miner's revenues on UTXO blockchains is equal to solving a variant of the knapsack problem in which items may have pairwise dependencies and conflicts. A transaction's weight is its size and its value is the transaction fee. Crucially, the transaction fees are fixed and known apriori. Moreover, when the miner chooses the subset of transactions that are included in her block, theisr order does not matter and any topological ordering leads to the same total revenue. Despite this, the problem is shown to be strongly NP-hard and can only be solved on sparse instances~\cite{bitcoinMining,pixiu}.

In contrast, our setting on Ethereum is considerably more challenging. Due to the gas model, the transaction fees are dynamic and depend on the actual resources used in runtime. The same transaction might pay vastly different fees based on the world state before its execution, which is determined by the transactions that precede it in the block. As a toy example, consider the smart contract below:

\begin{center}
\begin{lstlisting}[language=Solidity,basicstyle=\footnotesize,breaklines=true]
	uint n = 0;
	function f() public {n = 1000;}
	function g() public { 
		for(uint i=0;i<=n;i++) { 
			/*write to storage*/ 
		} 
	}
\end{lstlisting}
\end{center}


Suppose $\tx_1$ calls $\texttt{f}()$ and $\tx_2$ calls $\texttt{g}()$. 
If the miner places $\tx_1$ before $\tx_2$ in the block, $n$ becomes $1000$, so $\texttt{g}()$ incurs a high fee. If $\tx_2$ is first, $n=0$ when $\texttt{g}()$ runs, resulting in a much lower gas usage and fee. Thus, transaction ordering directly affects fees. Unlike the UTXO model, one cannot determine if $\tx_1$'s gas usage depends on $\tx_2$ by inspecting just the pair; dependencies may only arise in the presence of other transactions. For example, consider the smart contract below:

\begin{lstlisting}[language=Solidity,basicstyle=\footnotesize,breaklines=true]
	uint n = 0, m = 0;
	function f() public { m = 1000;}
	function g() public {
		for (uint i = 0; i <= n; i++) {
			/*write to storage*/
		}
	}
	function h() public {n = m;}
\end{lstlisting}

Suppose that the miner observes a transaction $\tx_1$ calling $\texttt{f}()$ and another transaction $\tx_2$ calling $\texttt{g}()$ in the mempool. These two transactions are clearly independent in terms of gas usage and each transaction's inclusion or their order cannot affect the fee paid by the other transaction. However, if a new transaction $\tx_3$ calling $\texttt{h}()$ is observed, then $\tx_1$ and $\tx_2$ suddently become dependent and the miner must use the ordering $\tx_1, \tx_3, \tx_2$ to maximize her payoff. Note that $\tx_2$ and $\tx_3$ are also independent in the absence of $\tx_1.$ Thus, we cannot talk of gas dependencies between a pair of transactions without specifying all transactions available in $\pool.$


\paragraph{MEV~\cite{ethereumMev}} The term \emph{Miner Extractable Value} or \emph{Maximal Extractable Value} (MEV) was popularized by~\cite{flashboys} to describe the maximum profit a dishonest miner can obtain by exploiting their knowledge of transactions. This is often called ``toxic'' MEV in the blockchain community. For instance, miners can engage in front-running, back-running, and sandwich attacks, leveraging their ability to manipulate, reorder, or censor transactions~\cite{mevAttack,tod,analysisTools}. Such attacks can even threaten the security of Ethereum's consensus layer~\cite{flashboys}. Several countermeasures against transaction reordering have been proposed~\cite{preventMev}, and formal verification tools exist to identify profitable MEV opportunities~\cite{clockwork,mevFc}.

MEV attacks typically involve the miner interacting with a smart contract. In most front-running attacks, for example, the miner observes a pending transaction $\tx_1$ and uses its disclosed data to create their own transaction $\tx_2$, placing it before $\tx_1$ in the block to capture the payoff. Here, the miner's extra revenue comes not from mining or transaction fees, but from exploiting a vulnerable contract. In contrast, our work focuses on honest miners. In our formalization (Section~\ref{sec:mining-ethereum-prelim}), the miner seeks to maximize revenue from the available transactions, without attacking contracts, forking the blockchain, or creating new transactions. This distinction makes our approach suitable for reference implementations of programmable blockchains, which are widely used by real-world miners. Notably, all major consensus protocols, including proof of work and proof of stake, rely on the assumption that the majority of mining power is held by honest miners.