
\section{Blockchain and Smart Contracts} \label{sec:prelim-blockchain}
\paragraph{Blockchain} As pioneered by Bitcoin~\cite{nakamoto2008bitcoin}, most modern cryptocurrencies use a blockchain protocol. There are three fundamental objects: transactions, blocks, and the blockchain. Transactions are the basic units of record keeping, defining the cryptocurrency's history and order. In Bitcoin, transactions transfer money in the underlying cryptocurrency. Anyone can create and broadcast transactions, which must be validated, e.g.~by checking digital signatures to prove ownership. Valid transactions are spread across the network using a peer-to-peer gossip protocol. Valid transactions are grouped into blocks of fixed maximum size, and each block contains a hash pointer to the previous block, forming a singly-linked list called the blockchain. Each node maintains a local copy of the blockchain, so its history consists of all transactions in its chain, which also provides their ordering.



\paragraph{Consensus mechanism} To ensure consensus, not every propagated transaction is finalized immediately; a consensus mechanism is required to make all nodes eventually agree on the blockchain's contents. Its purpose is to make adding new blocks subject to rules that prevent attackers from creating competing branches, or forks, which represent incompatible transaction histories. There are many consensus protocols~\cite{xu2023survey, dziembowski2015proofs, chatterjee2019hybrid, ball2017proofs, yin2019hotstuff}, with the most prominent being proof of work, used by Bitcoin~\cite{nakamoto2008bitcoin} and Ethereum Classic, and proof of stake~\cite{king2012ppcoin, kiayias2017ouroboros}, used by Ethereum~\cite{wood2014ethereum}, Cardano~\cite{david2018ouroboros}, and Algorand~\cite{chen2019algorand1}. In practice, different terms are used for miners; for example, Ethereum and most proof-of-stake currencies use \emph{validators} or \emph{block builders} to indicate they do not use proof of work. In this thesis, we use the term \emph{miner} for all consensus mechanisms.

\paragraph{Mining} Every blockchain protocol requires a process to extend the chain by adding new blocks. This process is often called \emph{mining} in proof-of-work blockchains such as Bitcoin~\cite{nakamoto2008bitcoin} and entails finding a solution to a proof-of-work puzzle which is often based on inverting hash functions. While proof-of-stake blockchains~\cite{king2012ppcoin, kiayias2017ouroboros} and other alternative consensus mechanisms such as proof-of-space~\cite{park2018spacemint} do not require the expensive step of solving a hash puzzle, they nevertheless need rules for extending the chain. The nodes that take part in chain extension are known by various names such as validators, farmers or producers. For simplicity, in this thesis, we simply use the words \emph{miner} and \emph{producer} to refer to any node on the network who tries to add a new block to the blockchain according to the underlying consensus protocol. 

\paragraph{Mining Steps} A miner has to first form a block by choosing a set of unmined transactions. Following Bitcoin~\cite{nakamoto2008bitcoin}, most blockchain protocols have a maximum size limit on the blocks, thus the miner has to strategically pick the transactions that are included in her block. The miner then proposes the block by publicly announcing it. The proposed block may or may not be adopted by the network, based on its rules of consensus. For example, in a proof-of-work cryptocurrency, only blocks that contain a valid solution to the hash puzzle may be accepted by the network.

\paragraph{Transaction Fees} Given that consensus heavily relies on miners and that mining is often costly, especially in proof-of-work settings, the protocol must provide rewards to incentivize mining. The miners are paid a fixed reward for every block they add to the blockchain. This is also how new units of currency are created. Additionally, to incentivize the miners to create non-empty blocks, a user who creates a transaction can decide on a transaction fee, which will be paid to the miner who adds it to the blockchain. It is well-known in the community that transactions with low fees are often ignored by the miners.

\paragraph{Smart Contracts} 
Bitcoin supports a limited scripting language for specifying conditions to spend a UTXO, such as requiring multiple signatures. In contrast, programmable blockchains, pioneered by Ethereum~\cite{wood2014ethereum}, allow arbitrary scripts in a Turing-complete language. The key idea is that blockchain consensus is independent of transaction type, enabling transactions beyond simple currency transfers. On Ethereum, a transaction can: (i)~transfer money, (ii)~deploy a \emph{smart contract}—a program in Ethereum Virtual Machine (EVM) bytecode, or (iii)~interact with existing smart contracts by calling their functions. A smart contract is a program added to the blockchain, making its code immutable. Each contract has dedicated storage and can hold currency. Once money is sent to a contract, it can only be recovered if the contract’s code transfers it elsewhere. Since the protocol provides consensus on transaction history, it also extends to the state of every contract, as all nodes can execute the transactions.

\paragraph{Design Choices in Blockchains} While blockchains share fundamental principles, their differences, such as programming language and execution environment, can influence tasks such as smart contract optimization. Blockchains typically employ either imperative or functional programming languages. Imperative languages, such as Solidity used by Ethereum, execute instructions sequentially, while functional languages, like Plutus on Cardano, rely on nested function calls. Imperative languages offer straightforward control flow and are familiar to most developers, making them easier to learn and use for a wide range of applications. In contrast, functional languages emphasize immutability and stateless computation, which can enhance security and facilitate formal verification. In terms of execution environment, Ethereum adopts an account-based model with a global state, enabling complex contract interactions, whereas Cardano uses a UTXO-based model with local state, facilitating better parallelization~\cite{wood2014ethereum,foundationnoyearplutus}.

We next review Bitcoin, Cardano, and Ethereum, emphasizing aspects relevant to this thesis.


\section{Bitcoin Architecture}
\label{sec:prelim-bitcoin}

\paragraph{Bitcoin} Bitcoin~\cite{nakamoto2008bitcoin} was the first working protocol for a decentralized cryptocurrency and currently holds the largest market cap among all such currencies, 
amounting to more than 1.4 trillion USD at the time of writing~\cite{coinmarketcap2024cryptocurrency}\footnote{The time of writing is April 1st, 2024.}. 
There is also a huge derivatives market on Bitcoin with trade volumes that often exceed 1 trillion USD per calendar month and have recently even exceeded 2 trillion USD per month (Section~\ref{sec:options-future}).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{chapters/options/bitcoin.pdf}
	\caption{A simplified view of the blockchain}
	\label{fig:options-bitcoin}
\end{figure} 

\paragraph{Proof-of-Work~\cite{nakamoto2008bitcoin, gervais2016security}} In Bitcoin, transactions are grouped into \emph{blocks} of a fixed maximum size. The blocks are then chained together in a singly-linked list using hash pointers with each block containing the hash of its parent (previous) block. This linked list is aptly named the \emph{blockchain}. The blockchain is subject to consensus, i.e.~all honest nodes on the network should eventually agree on its contents. Thus, adding a new block to the end of the blockchain is a deliberately hard task, called \emph{mining}, that requires the solution of a computationally-intensive hash inversion puzzle. This scheme is called \emph{proof-of-work} and ensures that a miner's chance of adding the next block to the blockchain is proportional to the miner's computational power, i.e.~how many hashes she can compute per unit of time.

Figure~\ref{fig:options-bitcoin} shows an overview of this process. In this figure we have omitted implementation details that are not relevant to this thesis. Each block $B_i$ contains the hash of the previous block $B_{i-1}.$ This serves as a hash pointer in the linked list. It also contains a nonce $n_i$ and a sequence of transactions $Tx_{i,1}, Tx_{i,2}, \ldots.$ A miner who aims to add a new block $B_{i+1}$ should first create the pointer to the previous block and populate a list of transactions that she intends to include. She should then choose the new nonce $n_{i+1}$ such that the hash $h(B_{i+1})$ of her new block is below a certain predefined threshold\footnote{In Bitcoin, the threshold changes dynamically to ensure that a new block is mined roughly every 10 minutes.}. Since the output of a hash function is unpredictable and an ideal cryptographic hash function can be modeled as a random oracle, the miner's only choice is to repeatedly try different nonces until she finds a valid block. Thus, her success probability is proportional to the number of hashes she can compute per unit of time.

Since mining is an expensive activity, due to both hardware and electricity costs, the miner should be financially incentivized to perform it. Bitcoin creates two incentives for the miner~\cite{meybodi2022optimal, nakamoto2008bitcoin, barakbayeva2024blockchain}: (a)~a block reward (currently 6.25 BTC $\approx$ 445,835 USD, expected to halve in almost three weeks from now) is paid to each miner who successfully adds a new block, and (b)~each transaction contains a transaction fee that is paid to the miner who adds it to the consensus chain.

\paragraph{UTXO} In Bitcoin~\cite{nakamoto2008bitcoin}, each transaction has multiple inputs and outputs: inputs are coins entering the transaction, outputs are coins leaving. Each input must reference an output from a previous transaction, ensuring only previously received coins can be spent. To prevent double-spending, each output can be spent only once. Spendable coins are called Unspent Transaction Outputs (UTXOs). Although UTXOs can be reconstructed from history, Bitcoin nodes maintain a current UTXO set for efficient transaction and block validation. Since transactions cannot create new coins, the sum of outputs must be less than the sum of inputs; the difference is paid to the miner as a transaction fee. Thus, each transaction has a fixed, known fee independent of other transactions. 

% \paragraph{Architecture (Nodes, Mempool, and Block Structure)} TODO: Full nodes, mempool, block header/tx list, Merkle root, propagation constraints.
% \paragraph{Bitcoin Scripting Language} TODO: Script as spending predicate language (stack-based, restricted); mention typical policies (multisig/timelock).

\paragraph{Longest Chain Rule~\cite{nakamoto2008bitcoin, blum2020combinatorics}} In the event that two miners find a valid block at approximately the same time, a temporary \emph{fork} happens in which there are two valid blockchains known to the network. In such a scenario, the Bitcoin protocol allows miners to try to extend either branch. However, as soon as a branch becomes longer than the other(s), the shorter branch(es) are dropped by everyone who honestly follows the protocol. Thus, the protocol mandates that the longest chain is always the consensus chain and that every node on the network must always consider the longest chain known to them as the authoritative blockchain\footnote{In practice, the length of a chain is not just the number of blocks in it, but rather the total difficulty of mining these blocks. However, this minor detail does not change any of the analyses in this thesis.}. This is illustrated in Figure~\ref{fig:options-longest}. As long as a majority of the computational power on the network follows the protocol honestly, all honest participants are guaranteed to eventually reach a consensus about the blockchain.

\begin{figure}
	\center
	\includegraphics[width=0.8\linewidth]{chapters/options/longest.pdf}
	\caption{An illustration of the longest chain rule in Bitcoin}
	\label{fig:options-longest}
\end{figure}

\paragraph{Double-Spending~\cite{rosenfeld2014analysis, nakamoto2008bitcoin, karame2012double, chaudhary2020double, karame2015misbehavior}} Preventing double-spending is arguably the main contribution of the Bitcoin protocol. A \emph{double-spending} attack is when a Bitcoin user tries to use the same coin (transaction output) in two different transactions. In such cases, the two transactions will be in conflict~\cite{meybodi2022optimal} and at most one of them can be added to the consensus chain. Specifically, if $Tx_1$ and $Tx_2$ both spend the same coin, then any proposed block that contains $Tx_1$ can only be valid if neither it nor any of its ancestors (previous blocks) contain $Tx_2.$
Suppose $\alice$ is selling an item to $\bob$ and $\bob$ is paying the price by a Bitcoin transaction $Tx_1$ that transfers part of his money to $\alice$. In this case, it is not enough for $\alice$ to see $Tx_1,$ since $\bob$ might have created a conflicting transaction $Tx_2$ that double-spends the same coin. Thus, $\alice$ should wait for $Tx_1$ to be added to the consensus chain. However, even this does not guarantee that the payment is finalized, since it is possible that the miner eventually creates a longer chain that contains $Tx_2$ and thus consensus switches from $Tx_1$ to $Tx_2.$ In such cases, we would say that $Tx_1$ is \emph{reverted}. In practice, this is unlikely to happen if $Tx_1$ is already in a block $B_i$ and there are many blocks added after $B_i.$ Such blocks are called \emph{confirmation} blocks. The conventional wisdom and industrial standard practice is to wait for 6 confirmations before considering the transaction as irreversible, although some users take the risk of waiting for fewer confirmations~\cite{hou2020study}.
% TODO add a short sentence about majority attack

\section{Cardano Architecture}
\label{sec:prelim-cardano}

\para{Cardano~\cite{hoskinson2017why}} Cardano is an open and decentralized blockchain platform that supports many cryptocurrencies and tokens. Its main currency, Ada, is currently one of the top 10 cryptocurrencies in terms of market cap and has a value of more than 16 billion USD~\cite{coinmarketcap2024cryptocurrency1}. Similar to Bitcoin, Cardano follows the (extended) UTXO model~\cite{foundation2017eutxo}, in which every transaction has a set of inputs and outputs. Each input to a transaction should be an output of a previous transaction and no output may be spent (used as input) twice. It has two major advantages over Bitcoin: (i)~support for arbitrarily complex smart contracts, i.e.~transactions can invoke executions of programs in an expressive programming language, and (ii)~a proof-of-stake consensus protocol, namely Ouroboros Praos~\cite{david2018ouroboros}, which avoids the costly mining process of Bitcoin's proof-of-work. In this section, we consider a simplified model of a Cardano transaction that precisely captures those aspects which are important to this thesis. For a more thorough treatment, see~\cite{hoskinson2017why} or~\cite{brunjes2020utxo}.

\para{EUTXO} Most modern blockchains either follow the Unspent Transaction Output (UTXO) model, as in Bitcoin~\cite{nakamoto2008bitcoin}, or the account model, as in Ethereum~\cite{wood2014ethereum}. To take advantage of the benefits of both models, Cardano proposes the Extended~UTXO (EUTXO) model that allows having more expressive programs than simple scripts without adopting the account model. In UTXO, a transaction has a set of inputs and outputs. An input points to an output of a prior transaction that provides funds to be spent by this transaction. Moreover, every output can be used by at most one input. EUTXO follows the same policies except that there is one more output field called ``datum'' that carries contract-specific data. In addition, EUTXO allows the inclusion of arbitrary logic as scripts and the use of the data fields to decide if the transaction output can be spent. See~\cite{foundation2017eutxo, brunjes2020utxo} for a more detailed treatment. 

% \para{Smart Contracts and Scripting} TODO: Explain validator scripts, datum/redeemer/context; mention Plutus~\cite{foundationnoyearplutus}.

\para{Proof-of-Stake~\cite{documentation2024proof, king2012ppcoin, kiayias2017ouroboros}} In proof-of-stake protocols, a miner is randomly chosen to add the next block. Each miner's probability of being chosen is proportional to her stake in the currency, i.e.~the number of coins she holds. Specifically, in Cardano's implementation of Ouroboros Praos~\cite{david2018ouroboros}, time is divided into epochs, each consisting of 432,000 slots. Each slot corresponds to one second. Thus, each epoch lasts for five days. In each slot, some miners/producers are randomly selected to propose blocks of transactions~\cite{documentation2024slots}.  

\para{Stake Pools and Delegation~\cite{documentation2024stake}} Any user who holds Ada can take part in mining (block production) on Cardano. Users can also delegate their mining rights (stakes) to others, leading to stake pools which, as the name suggests, pool together stakes from many different users. The pool operator can then mine on behalf of all of its users and the probability that the pool is selected in each slot is proportional to the total stake of the members. The vast majority of Cardano blocks are produced by stake pools rather than individual stakeholders. 

\para{Rewards} Producing blocks is a costly process. This is of course evident in proof-of-work blockchains, in which the miners have to solve hash puzzles requiring vast computational resources and electricity usage. Thus, Bitcoin rewards miners for every new block that they successfully add to the blockchain and also pays them transaction fees~\cite{nakamoto2008bitcoin}. Even in proof-of-stake blockchains, there are costs associated with block production, e.g.~the miner has to keep track of the whole history of the chain, constantly listen for new transactions, hold stake or convince others to delegate stakes to her, form valid blocks of transactions and announce/propose them on time. Therefore, it is necessary to incentivize block production by rewarding the miners. In Cardano, the block producers are rewarded in two ways~\cite{documentation2024pledging}:
\begin{enumerate}
	\item \emph{Transaction Fees:} Every transaction contains a fixed fee. After each epoch, the fees of all transactions mined in that epoch are divided among the block producers.
	\item \emph{Monetary Expansion:} For each epoch, a fixed percentage of the remaining reserve of Ada is paid to all block producers of the epoch. 
\end{enumerate}

\para{Block Constraints} 
In Cardano's EUTXO model, a block contains a sequence of valid transactions. The transactions in each block must satisfy the following requirements, otherwise the block is considered invalid and will be discarded by all nodes of the network. 

\begin{itemize}
\item \textit{Transaction Dependencies.}
If a transaction $t_2$ uses an output of another transaction $t_1$ as one of its inputs, then $t_2$ depends on $t_1.$ If the block producer decides to include $t_2$ in her new block, then she must also add $t_1$ in the same block and before $t_2$. See Figure~\ref{fig:prelim-cardano-dep} as an example.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75]{chapters/mining/mining-cardano-figures/dependency.pdf}
	\caption{Alice pays 15 Ada to Bob in $t_1$. In $t_2$ Bob uses the same funds to pay 10 Ada to Carol and 5 Ada back to himself. The transaction $t_2$ has an input that is using an output of $t_1.$ Thus, $t_1$ is a dependency of $t_2.$}
	\label{fig:prelim-cardano-dep}
\end{figure}

\item \textit{Transaction Conflicts.} 
If two transactions $t_2$ and $t_3$ both spend the same output of a transaction $t_1$, since every output may be spent at most once, only one of the conflicting transactions may be selected and included in the new block. Thus, the block producer has a choice to include $t_2, t_3$ or neither in the new block, but she cannot include both. See Figure~\ref{fig:prelim-cardano-conf} as an example.

\begin{figure}
	\centering
	\includegraphics[scale=0.6]{chapters/mining/mining-cardano-figures/conflict.pdf}
	\caption{In an auction contract, Alice has bid 5 Ada in $t_1$. Both Bob and Carol are trying to bid right after Alice, hence using $t_1$'s datum output as input to their transactions $t_2$ and $t_3$. Since every output can be used only once, $t_2$ and $t_3$ are in conflict.}
	\label{fig:prelim-cardano-conf}
\end{figure}
 

\item \textit{Block Size Limit.}
Cardano imposes a block size limit, i.e.~the total size of all transactions included in a new block must not exceed 90112 bytes = 88 kilobytes. This is to ensure that the blocks are small enough to be efficiently propagated within the network with minimal latency. The block size limit may change in each epoch, but in practice it has been consistently kept at 88 kilobytes.
\end{itemize}



\section{Ethereum Architecture}
\label{sec:prelim-ethereum}

This section provides a quick introduction to Ethereum and its gas model, following~\cite{wood2014ethereum, dameron2019beige}.

% \para{Architecture (Execution and Consensus)} TODO: Execution layer (EVM/world state) vs consensus layer; mempool; (optional) PBS/MEV context.
% \para{Consensus Model (Proof-of-Stake)} TODO: Validator roles, fork choice vs finality, and reorg/finality intuition (e.g.~\cite{zhang2025available}).

\para{Smart Contracts} Ethereum~\cite{wood2014ethereum} allows arbitrary programs written in a Turing-complete language, which are called \emph{Smart contracts}. Most other modern cryptocurrencies have followed Ethereum and enabled smart contracts. More specifically, a transaction in Ethereum can not only transfer money as in Bitcoin, but also perform other tasks:
\begin{compactitem}
	\item \emph{Deployment of a Contract.} A transaction can contain the code of a program, i.e.~a smart contract, and hence deploy it on the blockchain. Simply put, when this transaction is included in a block and then added to the blockchain, every node in the network has access to the smart contract's code, which is now part of the consensus. Moreover, the code is immutable since the blockchain is append-only. 
	\item \emph{Function Calls.} A transaction can ``call'' a desired function in a smart contract that was deployed by a previous transaction. To do so, the transaction has to provide a pointer to the smart contract, the name of the called function, and the parameters passed to it. A transaction record containing all this data will be added to the blockchain.
\end{compactitem} 

\paragraph{Account Model} There is no concept of UTXO on Ethereum. Instead, every node on the Ethereum network keeps track of the so-called \textit{world state}~\cite{wood2014ethereum}. The world state consists of a number of \textit{accounts}.



\para{Accounts} In Ethereum, the currency unit is called an ``ether'' and uses the acronym ETH. An account is an entity with an ether (ETH) balance that can transfer money on Ethereum. It is either controlled by a user or a deployed smart contract. 

The state of an account consists of the following fields: 
\begin{itemize}
   \item \texttt{nonce}: The number of transactions sent from the account. 
   \item \texttt{balance}: The amount of ether owned by this account. 
   \item \texttt{codeHash}: This is only for contract accounts and contains the hash of the contract's code. 
   \item \texttt{storageRoot}: Each account has a storage, e.g.~for storing records and global variables in a contract. The storage is encoded in a Merkle-Patricia tree. The \texttt{storageRoot} is a hash pointer to the root of this tree.
\end{itemize}

\para{Transactions} A user can publish an Ethereum transaction to transfer money, deploy a new contract and change the blockchain state. 

\para{Blockchain State} In Ethereum, the complete blockchain state includes not only the sequence of blocks, but also implicitly contains the \emph{world state} and the \emph{machine state}. Most Ethereum nodes keep track of these explicitly. The world state represents the states of all accounts, which includes balances for everyone and the storage state of every smart contract. The machine state is the state of the Ethereum virtual machine during execution and contains global variables such as the block number. Transactions and blocks change the blockchain state, especially the world state. 

\para{EVM} The Ethereum Virtual Machine (EVM) deterministically and unambiguously describes the rules of executing transactions on Ethereum. EVM supports a set of operations (opcodes) to interact with input call data, stack, memory, storage and the blockchain world state. 


\para{Solidity~\cite{foundation2014misc}} Solidity is an object-oriented, high-level Turing-complete language for implementing Ethereum smart contracts and the most widely-used smart contract language. Solidity supports all the standard data types and data structures such as arrays and mappings. The functions in Solidity contracts can call other functions from the same contract or external public functions  by specifying the function signatures and contract addresses. 

% \para{Other Contract Languages} TODO: Briefly mention other EVM languages (e.g., Vyper/Yul) and compilation to bytecode.

\paragraph{Gas} As the EVM language is Turing-complete, one can write and invoke contracts whose execution uses huge or even infinite time and memory. This is undesirable given that every transaction has to be run by all nodes on the network. Thus, intentionally executing long or resource-intensive contracts is a type of denial-of-service (DoS) attack. To combat this, Ethereum introduced the concept of \emph{gas}~\cite{foundation2025gas}. Gas is a measure of the total resources required to run an invocation. A gas cost is assigned to every atomic operation in the EVM language, including memory usage or deploying code. The costs of atomic operations are part of the protocol and provided as a table in~\cite{dameron2018beigepaper}. The initiator of a transaction has to pay a transaction fee proportional to the total gas cost of its execution. This effectively disincentivizes long and resource-hungry executions. Moreover, every block has a gas limit, which was originally set at 30,000,000 units of gas but has recently increased to 36,000,000. If the sum of gas usages of all transactions in a block exceeds this limit, the block is considered invalid and will not be added to the blockchain. This ensures that every node will have to perform only a limited amount of computation for each block.

% \paragraph{Fee Market (EIP-1559 Intuition)} TODO: Explain base fee vs tip, burning, and how users specify fee caps.

\para{Deposits and Out-of-gas Behavior} The user who initiates a transaction (function call to a smart contract) can specify the maximum amount of gas that the transaction is allowed to spend, as well as the price that the user is willing to pay per unit of gas\footnote{After the London upgrade in Ethereum, there is a minimum base price that the user must pay or else the transaction is invalid. However, this has no effect on our algorithms, since they all consider gas usage itself and are independent of the gas price.}. They should then provide a deposit equal to the product of the two parameters. When the transaction is added to the blockchain, every node in the network executes it, while keeping track of the amount of gas that is being used. If the function call requires more than the allocated gas, then not only the deposit is confiscated but the call itself is reverted and canceled, i.e.~all effects of this function call, be it on user's balances or the variables of the smart contracts, will be reverted as if this function call never existed. The only effect is that the initiator loses their deposit.

\para{Gas Usage Formula} The Ethereum protocol fixes a specific gas cost for every one of the EVM opcodes using a complicated formula to address the different computational workloads of different opcodes. See~\cite[Page 14]{dameron2019beige} for a complete table of gas costs. We follow these costs in our implementation but their specific values have no bearing on the theory. In summary:
\begin{itemize}
    \item Most opcodes have fixed constant gas costs. For example, stack operation opcodes \texttt{PUSHx}, \texttt{POPx} and \texttt{SWAPx} have a gas cost of 3 units each. 
	\item Some opcodes have a few different gas costs given different conditions. The \texttt{SSTORE} opcode is an example, which saves a word to storage. The gas cost is 20,000 if it is overwriting a zero with a non-zero value, and 5,000 otherwise. Moreover, if the operation clears a non-zero to a zero, then 15,000 units of gas are refunded, but this refund is made only if the current transaction uses more than 15,000 units of gas. Since these conditions are unnecessarily complicated and depend on the dynamic world state, and since they are not specified by the smart contract itself, we always replace them with their highest possible value to preserve soundness, e.g.~we always assume that an \texttt{SSTORE} takes 20,000 units of gas.
    \item The gas costs of some operations depend on the size of a particular stack or array. For example, taking the hash of a piece of data that is $n$ bytes long has a dynamic cost that is linearly dependent on $n$. To handle these cases, we always keep track of the sizes of the stacks/arrays as separate variables. Notably, while these costs are not constants, they are always polynomials (but not necessarily linear) with respect to their input size $n.$
\end{itemize}
