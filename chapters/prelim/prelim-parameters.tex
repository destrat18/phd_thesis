\section{Graph Sparsity Parameters}
\label{sec:prelim-parameters}

\subsection{Parameterized Complexity and FPT}

This work uses parameterized algorithms, which leverage specific structural features of problem instances to achieve faster solutions. We present the essential definitions here; see Downey and Fellows~\cite{downey2013fundamentals} (Chapter 2) for comprehensive technical discussions.

\para{Parameterized Problem Definition} We consider problems with multiple inputs, formalized as languages over two components. If a pair $\langle x, k \rangle$ belongs to such a language $L$, we call $k$ the parameter. The parameter typically takes integer values, though it may represent other structures such as graphs or algebraic objects. 

\para{Fixed-Parameter Tractability (FPT)~\cite{downey2013fundamentals}}
Formally, a parameterized language $L$ is \emph{fixed-parameter tractable} (FPT) if the following hold:
\begin{itemize}
    \item There exists an algorithm $\Phi$, a constant $c$, and a computable function $f$ such that for all instances $x, k$, $\Phi(\langle x, k \rangle)$ runs in time $f(k) \cdot |x|^c$,
    \item $\Phi(\langle x, k \rangle) = 1$ if and only if $\langle x, k \rangle \in L$.
\end{itemize}

Intuitively, this means that for each fixed value of the parameter $k$, the problem can be solved in polynomial time with respect to the input size $|x|$, where the degree of the polynomial does not depend on $k$. The potentially expensive part of the computation is isolated in the function $f(k)$, which can grow quickly, but for small $k$ the overall running time remains practical. This framework allows many NP-hard problems to become efficiently solvable when the parameter is small, even if the general problem is intractable.


\subsection{Tree Decompositions and Treewidth}
\label{sec:prelim-parameters-treewidth}

The treewidth of a graph $G=(V, E)$ is defined via a \textit{tree decomposition}. A tree decomposition is a pair $(\mathcal{T}, \{X_i \mid i \in I\})$, where $\mathcal{T}=(I, F)$ is a tree and each $X_i$ (called a bag) is a subset of $V$, satisfying:
\begin{enumerate}
    \item The union of all bags equals $V$; i.e., $\bigcup_{i \in I} X_i = V$.
    \item For every edge $(u,v) \in E$, there is at least one bag $X_i$ containing both $u$ and $v$.
    \item For any vertex $v \in V$, the set of bags containing $v$ forms a connected subtree in $\mathcal{T}$.
\end{enumerate}

The \textit{width} of a tree decomposition is $\max_{i \in I} |X_i| - 1$. The \textit{treewidth} of a graph $G$, denoted $tw(G)$, is the minimum width over all possible tree decompositions of $G$. A low treewidth indicates a structure amenable to efficient dynamic programming, a property that we exploit extensively in Chapter~\ref{chp:hermes}.


\subsection{Treedepth Decomposition}
\label{sec:prelim-parameters-treedepth}

For a graph $G= (V, E),$ a \emph{treedepth decomposition}~\cite{nevs2012bounded, iwata2017power, nevs2015low} is a rooted tree $T = (V, E_T)$ on the same set of vertices as $G$ that satisfies the following requirement:
\begin{itemize}
	\item For every undirected edge $\{u, v\} \in E$ or directed edge $(u, v) \in E$ of the original graph, either $u$ is an ancestor of $v$ in $T$ or $v$ is an ancestor of $u$ in $T.$
\end{itemize}
We say that a treedepth decomposition $T$ is optimal if it has the smallest possible depth a\textbf{Definition 2.1.1 (The basic definition)} mong all decompositions of $G.$ This smallest depth is called the \emph{treedepth} of $G.$ Intuitively, treedepth is a measure of graph sparsity that captures how much a graph resembles a shallow tree.

For any small fixed $d,$ there is an algorithm that decides whether an input graph has treedepth $d$ in linear time and if so, outputs an optimal treedepth decomposition~\cite{reidl2014faster}. There are also well-optimized tools and libraries for computing treedepth decompositions~\cite{strasser2020pace}. 