\section{Gas Optimization Problem}\label{sec:superopt-problem} 


\paragraph{Gas Optimization} Analyzing and reducing gas costs are central research problems in the blockchain community. Out-of-gas errors are the source of many vulnerabilities and thus there are several tools focused on finding upper-bounds on the gas usage of smart contracts~\cite{DBLP:conf/marble/NassirzadehSBG22,DBLP:journals/jss/AlbertCGRR21,DBLP:journals/pacmpl/CaiFGH23}. In 2023, on Ethereum alone, gas costs were more than 4 billion USD~\cite{gast}. Given this high cost, and the fact that gas usage is defined for low-level bytecode operations whereas programmers write their contracts in high-level languages such as Solidity, it is crucial that the compiler optimizes for gas usage. Indeed, the standard Solidity compiler \texttt{solc} has a flag \texttt{--optimize} which enables heuristics for optimizing the gas usage of the resulting bytecode. The Solidity language documentation~\cite{solidity} also talks about \emph{gas-hungry} patterns and instructs programmers to avoid them in their code. There are many works on layer-two protocols which aim to minimize the amount of on-chain computation, i.e.~gas-consuming calls to smart contracts, by moving most of the protocol off-chain~\cite{DBLP:journals/access/ThibaultSH22} or delaying and avoiding the execution as far as possible~\cite{DBLP:conf/icbc2/FarokhniaG23}.


\paragraph{Superoptimization} The current state-of-the-art in gas optimization by compilers is the work~\cite{DBLP:journals/tosem/AlbertGHRS22} which provides a tool called \texttt{syrup 2.0} that supports both Solidity source code and EVM bytecode as its input and outputs gas-optimized bytecode. Their approach is based on the concept of superoptimization~\cite{DBLP:conf/asplos/Massalin87}. Basically, the idea is to break the bytecode program down into its basic blocks, i.e.~maximal straight-line subprograms that do not contain branching or jumps. Then, each basic block $\bb$ is optimized separately by exhaustively trying all possible rewritings $\bb'$ that are equivalent to $\bb$ and taking the one with the smallest gas usage. Superoptimization is a well-known technique that has been implemented in mainstream tools and compilers such as LLVM~\cite{DBLP:conf/cgo/LattnerA04,DBLP:journals/corr/abs-1711-04422} usually with the goal of reducing runtime or memory usage. However, exhaustive search is far from scalable and can only be applied to toy programs with tiny basic blocks. For example, a \texttt{C++} basic block containing the single operation \texttt{x*=2} can easily be rewritten as \texttt{x<<1}, reducing its execution time, but as the size of the block grows there will be a combinatorial explosion in the number of possible rewritings. Instead,~\cite{DBLP:journals/tosem/AlbertGHRS22} encodes the problem as \texttt{Max-SMT} and passes it to modern SMT-solvers. This encoding, and the rewrite rules for obtaining equivalent basic blocks, are far from trivial. Indeed,~\cite{DBLP:journals/tosem/AlbertGHRS22} provides several different encodings and experimentally finds the best combinations. The reduction to \texttt{Max-SMT} is the key to \texttt{syrup}'s scalability and enables huge savings in real-world gas costs of Ethereum smart contracts.

\begin{example} 
    Consider a simple basic block in Solidity that performs the operation $y = x \XOR x.$ Here, $x$ and $y$ are integers and $\XOR$ is the bitwise exclusive or operation. Our goal is to compile this basic block to EVM bytecode. A naive compiler that applies no optimization, such as \texttt{solc} with all optimizations turned off, would provide the bytecode in Figure~\ref{fig:superopt-example} (left). In EVM bytecode, \textcolor{Blue}{\texttt{PUSH}} adds a new item to the top of the stack, \textcolor{Blue}{\texttt{POP}} removes the top item, \textcolor{Blue}{\texttt{SLOAD}} loads a word from storage, \textcolor{Blue}{\texttt{DUP}} duplicates an item on the stack and \textcolor{Blue}{\texttt{SWAP}} swaps items in the stack. As expected, \textcolor{Blue}{\texttt{XOR}} performs the bitwise exclusive or operation. Each of these operations has a gas cost, which is fixed by the Ethereum Yellowpaper~\cite[Appendix H]{wood2014ethereum}. In this case, the naive compilation will lead to a total gas cost of 1,420 for this basic block.  In contrast, a compiler that realizes $x \XOR x = 0$ and thus rewrites $y = x \XOR x$ as $y = 0$ would not even need to perform the \textcolor{Blue}{\texttt{XOR}} operation. This leads to a much more gas-efficient bytecode such as the one in Figure~\ref{fig:superopt-example} (center). This is the output of \texttt{syrup} and uses only 720 units of gas, almost halving the execution cost. Finally, it is possible to further optimize even this bytecode, obtaining the basic block in Figure~\ref{fig:superopt-example} (right), which uses 706 units of gas. Note that all three basic blocks of Figure~\ref{fig:superopt-example} are semantically equivalent and differ only in their gas usage.
\end{example}

\begin{figure}
	\begin{center}
	\begin{minipage}{0.2\linewidth}
	\lstinputlisting{chapters/superopt/superopt-figures/naive.txt}
	\end{minipage}
	\begin{minipage}{0.2\linewidth}
	\lstinputlisting{chapters/superopt/superopt-figures/syrup.txt}
	\end{minipage}
	\begin{minipage}{0.2\linewidth}
	\lstinputlisting{chapters/superopt/superopt-figures/opt.txt}
	\end{minipage}
\end{center}
	\caption{Three compilations of $y = x \XOR x$ to EVM bytecode: naive (left), optimized (center), and further optimized (right).}
	\label{fig:superopt-example}
\end{figure}

\paragraph{Our Fucus} In this chapter, we use \texttt{syrup} as a black box and design a simple and elegant dynamic programming algorithm for optimizing the gas usage of Ethereum smart contracts. Our algorithm is also a flavor of superoptimization, i.e.~it optimizes each basic block separately. We report significant improvements in the gas usage of the resulting smart contracts, not only in comparison with the unoptimized version, but also against \texttt{syrup} itself. 
